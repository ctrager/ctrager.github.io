<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Corey's Pitch Dectection</title>

    <style>
        #my_canvas {
            background-color: lightgoldenrodyellow;
            border: 1px solid gray;
            xwidth: 800px;
            xheight: 400px;
        }
        body {
            font-family: verdana, arial;
            font-size: 12px;
            margin: 20px;
        }

        button {
            font-size: 16px;
        }
    </style>
    
    <script type="text/javascript">
        var audioCtx
        var analyser
        var media_stream_source
  
        var user_media_constraints = {
            audio: true,
            video: false
        };

        var fft_array
       
        var running = false
        var ready = false
        var first_time = true

        var queue = []
        var note_el
        var notes_el
        var canvas_el
        var notes = []

        // important constants to tune
        const queue_length = 20
        const fftSize = 4096 // 2048, 4096, 8192, 16384, 32768
    
        // get_freq_via_yin constants
        const yin_threshold = 0.1
        const yin_probabilityThreshold = 0.1
  
        // canvas
        var ctx
        const canvas_width = 800
        const canvas_height = 400
        var staff_number = 1
        var col_number = 1
        const line_height = 8
        const staff_spacing = 40
        const col_spacing = 20
  

        function on_load() {

            note_el = document.getElementById("note")
            notes_el = document.getElementById("notes")
            canvas_el = document.getElementById("my_canvas")
            ctx = canvas_el.getContext("2d");

            draw_staff()

            // init the queue
            for (var i = 0; i < queue_length; i++) {
                queue.push(0)
            }

        }

        function init() {

            audioCtx = new(window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = fftSize
            fft_array = new Float32Array(analyser.fftSize)
  
            navigator.mediaDevices.getUserMedia(user_media_constraints)
                .then(function (stream) {
                    media_stream_source = audioCtx.createMediaStreamSource(stream);
                    media_stream_source.connect(analyser);
                    ready = true
                    console.log("ready")
                })
                .catch(function (err) {
                    console.log(err)
                })
        }

        function start() {
            if (first_time) {
                first_time = false
                init()
            }
            notes = []
            note_el.innerText = ""
            notes_el.innerText = ""
            running = true
           
            requestAnimationFrame(frame_callback)
        }

        function stop() {
            running = false
            ctx.clearRect(canvas_width, canvas_height)
        }

        function frame_callback() {

            if (!running) return;

            if (!ready) {
                requestAnimationFrame(frame_callback)
                return
            }

            //get_loudest_freq()
            analyser.getFloatTimeDomainData(fft_array);

            let freq = (get_freq_via_yin(fft_array, yin_threshold, yin_probabilityThreshold))

            // the freq is a float and jumps around a lot, so lets do a couple
            // things to steady it.  Rounds 123.4567 to 123.46, and take the most
            // frequently occuring value of the last N readings

            if (freq > 3000) {
                freq = 0
            }

            if (freq) {

                // Corey's hack. Save the last N frequencies and then pick the most common of the last N
                queue.shift()
                queue.push(freq.toFixed(1))
                let mode = get_mode(queue)

                let note = frequency_to_note(mode)
                note_el.innerText = JSON.stringify(note)

                // update array of notes
                if (notes.length == 0) {
                    notes.push(note)
                    col_number++
                    draw_note(note)
                } else {
                    last_note = notes[notes.length - 1]
                    if (note.letter == last_note.letter) {
                        last_note.cents = note.cents
                        
                        draw_note(note)
                    } else {
                        notes.push(note)
                        col_number++
                        draw_note(note)
                    }
                }
                notes_el.innerText = JSON.stringify(notes, null, 2)
            }

            //draw(notes)
            requestAnimationFrame(frame_callback)
        }
        
        function draw_note(note) {
            //var x = col_spacing * col_number
            var x = 40 * col_number
            if (x > (canvas_width - 20)) {
                staff_number++
                col_number = 1
                x = 40 * col_number
            }

            var y = .5
            y += staff_spacing * staff_number
       
            ctx.fillStyle = "red"
            ctx.beginPath();
            ctx.ellipse(x, y, (line_height/2) + 2, (line_height/2), 0, 0, 2 * Math.PI); //, 2 * Math.PI);
            ctx.fill();
        }

        function draw_staff() {
            
            ctx.lineWidth = 1
            var y = .5 // for crisp lines https://usefulangle.com/post/17/html5-canvas-drawing-1px-crisp-straight-lines
            //ctx.strokeStyle = "#FF0000";

            for (var row = 1; row < 5; row++) {
                y += staff_spacing
                for (var line = 0; line < 5; line++) {
                    y += line_height
                    ctx.beginPath()
                    ctx.moveTo(0, y)
                    ctx.lineTo(canvas_width, y)
                    ctx.stroke()
                }
            }    
        }

        // from https://github.com/peterkhayes/pitchfinder/blob/master/src/detectors/yin.ts
        function get_freq_via_yin(fft_array, threshold, probabilityThreshold) {

            // Set buffer size to the highest power of two below the provided buffer's length.
            let bufferSize;
            for (bufferSize = 1; bufferSize < fft_array.length; bufferSize *= 2);
            bufferSize /= 2;

            // Set up the yinBuffer as described in step one of the YIN paper.
            const yinBufferLength = bufferSize / 2;
            const yinBuffer = new Float32Array(yinBufferLength);

            let probability = 0,
                tau;

            // Compute the difference function as described in step 2 of the YIN paper.
            for (let t = 0; t < yinBufferLength; t++) {
                yinBuffer[t] = 0;
            }
            for (let t = 1; t < yinBufferLength; t++) {
                for (let i = 0; i < yinBufferLength; i++) {
                    const delta = fft_array[i] - fft_array[i + t];
                    yinBuffer[t] += delta * delta;
                }
            }

            // Compute the cumulative mean normalized difference as described in step 3 of the paper.
            yinBuffer[0] = 1;
            yinBuffer[1] = 1;
            let runningSum = 0;
            for (let t = 1; t < yinBufferLength; t++) {
                runningSum += yinBuffer[t];
                yinBuffer[t] *= t / runningSum;
            }

            // Compute the absolute threshold as described in step 4 of the paper.
            // Since the first two positions in the array are 1,
            // we can start at the third position.
            for (tau = 2; tau < yinBufferLength; tau++) {
                if (yinBuffer[tau] < threshold) {
                    while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {
                        tau++;
                    }
                    // found tau, exit loop and return
                    // store the probability
                    // From the YIN paper: The threshold determines the list of
                    // candidates admitted to the set, and can be interpreted as the
                    // proportion of aperiodic power tolerated
                    // within a periodic signal.
                    //
                    // Since we want the periodicity and and not aperiodicity:
                    // periodicity = 1 - aperiodicity
                    probability = 1 - yinBuffer[tau];
                    break;
                }
            }

            // if no pitch found, return null.
            if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {
                return null;
            }

            // If probability too low, return -1.
            if (probability < probabilityThreshold) {
                return null;
            }

            /**
             * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau
             * value using parabolic interpolation. This is needed to detect higher
             * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and
             * for more background
             * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html
             */
            let betterTau, x0, x2;
            if (tau < 1) {
                x0 = tau;
            } else {
                x0 = tau - 1;
            }
            if (tau + 1 < yinBufferLength) {
                x2 = tau + 1;
            } else {
                x2 = tau;
            }
            if (x0 === tau) {
                if (yinBuffer[tau] <= yinBuffer[x2]) {
                    betterTau = tau;
                } else {
                    betterTau = x2;
                }
            } else if (x2 === tau) {
                if (yinBuffer[tau] <= yinBuffer[x0]) {
                    betterTau = tau;
                } else {
                    betterTau = x0;
                }
            } else {
                const s0 = yinBuffer[x0];
                const s1 = yinBuffer[tau];
                const s2 = yinBuffer[x2];
                // fixed AUBIO implementation, thanks to Karl Helgason:
                // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1
                betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
            }

            return audioCtx.sampleRate / betterTau;
        }

        // frequency to note constants 
        const A4 = 440.0;
        const A4_INDEX = 57;

        const note_letters = [
            "C0", "C#0", "D0", "D#0", "E0", "F0", "F#0", "G0", "G#0", "A0", "A#0", "B0",
            "C1", "C#1", "D1", "D#1", "E1", "F1", "F#1", "G1", "G#1", "A1", "A#1", "B1",
            "C2", "C#2", "D2", "D#2", "E2", "F2", "F#2", "G2", "G#2", "A2", "A#2", "B2",
            "C3", "C#3", "D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3",
            "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4",
            "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5", "G5", "G#5", "A5", "A#5", "B5",
            "C6", "C#6", "D6", "D#6", "E6", "F6", "F#6", "G6", "G#6", "A6", "A#6", "B6",
            "C7", "C#7", "D7", "D#7", "E7", "F7", "F#7", "G7", "G#7", "A7", "A#7", "B7",
            "C8", "C#8", "D8", "D#8", "E8", "F8", "F#8", "G8", "G#8", "A8", "A#8", "B8",
            "C9", "C#9", "D9", "D#9", "E9", "F9", "F#9", "G9", "G#9", "A9", "A#9", "B9"
        ];

        const MINUS = -1;
        const PLUS = 1;
        const r = Math.pow(2.0, 1.0 / 12.0);
        const cent = Math.pow(2.0, 1.0 / 1200.0);
        
        // from https://newt.phys.unsw.edu.au/music/note/
        function frequency_to_note(input) {
            if ((input < 27.5) || (input > 14080))
                return ""

            var frequency;
            var r_index = 0;
            var cent_index = 0;
            var side;

            frequency = A4;

            if (input >= frequency) {
                while (input >= r * frequency) {
                    frequency = r * frequency;
                    r_index++;
                }
                while (input > cent * frequency) {
                    frequency = cent * frequency;
                    cent_index++;
                }
                if ((cent * frequency - input) < (input - frequency))
                    cent_index++;
                if (cent_index > 50) {
                    r_index++;
                    cent_index = 100 - cent_index;
                    if (cent_index != 0)
                        side = MINUS;
                    else
                        side = PLUS;
                } else
                    side = PLUS;
            } else {
                while (input <= frequency / r) {
                    frequency = frequency / r;
                    r_index--;
                }
                while (input < frequency / cent) {
                    frequency = frequency / cent;
                    cent_index++;
                }
                if ((input - frequency / cent) < (frequency - input))
                    cent_index++;
                if (cent_index >= 50) {
                    r_index--;
                    cent_index = 100 - cent_index;
                    side = PLUS;
                } else {
                    if (cent_index != 0)
                        side = MINUS;
                    else
                        side = PLUS;
                }
            }

            var letter = note_letters[A4_INDEX + r_index];

            return {
                letter: letter,
                cents: side * cent_index,
                freq: input
            }
        }

        // get most frequencly occuring value in an array, aka, the mode. from stackoverflow 
        function get_mode(array) {
            if (array.length == 0)
                return null;
            var modeMap = {};
            var maxEl = array[0],
                maxCount = 1;
            for (var i = 0; i < array.length; i++) {
                var el = array[i];
                if (modeMap[el] == null)
                    modeMap[el] = 1;
                else
                    modeMap[el]++;
                if (modeMap[el] > maxCount) {
                    maxEl = el;
                    maxCount = modeMap[el];
                }
            }
            return maxEl;
        }
    </script>
</head>

<body onload="on_load()">

    <div><button onclick="start()">start</button><button onclick="stop()">stop</button></div>
    <div><canvas id="my_canvas" width=800 height=400></canvas></div>
    <div id="note"></div>
    <div id="notes"></div>
</body>

</html>